function encode_motion_vectors(current_frame, reference_frame):
    macroblock_size = 16x16
    search_range = predefined_range

    for each macroblock in current_frame:
        best_mv = (0, 0)
        min_cost = ∞

        for dx in -search_range to +search_range:
            for dy in -search_range to +search_range:
                candidate_block = get_block(reference_frame, macroblock.position + (dx, dy))
                cost = compute_SAD(macroblock, candidate_block)

                if cost < min_cost:
                    min_cost = cost
                    best_mv = (dx, dy)

        predicted_mv = predict_mv_from_neighbors(macroblock)
        residual_mv = best_mv - predicted_mv

        encode_residual_mv(residual_mv)
        encode_macroblock(macroblock, candidate_block)

function compute_SAD(block1, block2):
    sad = 0
    for each pixel in block1:
        sad += abs(pixel - corresponding_pixel_in(block2))
    return sad

function predict_mv_from_neighbors(macroblock):
    left_mv = get_mv(macroblock.left)
    top_mv = get_mv(macroblock.top)
    top_right_mv = get_mv(macroblock.top_right)
    return median(left_mv, top_mv, top_right_mv)

function encode_residual_mv(mv):
    entropy_encode(mv.x)
    entropy_encode(mv.y)
