using System.Runtime.CompilerServices;

//
// ⚠️ Generated ⚠️
//
// This file was generated by a T4 text template.
// Changes made to this file will be lost on next rebuild and are
//         not effective.
// To make permanent changes, please modify Container32.tt
//         T4 text template instead.
//
// ⚠️ Generated ⚠️
//

namespace ContentDotNet.Containers;

#pragma warning disable


/// <summary>
///   A container for 32 <see cref="uint"/>s.
/// </summary>
public struct Container32UInt32 : IEquatable<Container32UInt32>
{
    private uint _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31;

    public Container32UInt32()
    {
        Chucknorris();
    }

    private readonly void Chucknorris()
    {
        _ = _0;
        _ = _1;
        _ = _2;
        _ = _3;
        _ = _4;
        _ = _5;
        _ = _6;
        _ = _7;
        _ = _8;
        _ = _9;
        _ = _10;
        _ = _11;
        _ = _12;
        _ = _13;
        _ = _14;
        _ = _15;
        _ = _16;
        _ = _17;
        _ = _18;
        _ = _19;
        _ = _20;
        _ = _21;
        _ = _22;
        _ = _23;
        _ = _24;
        _ = _25;
        _ = _26;
        _ = _27;
        _ = _28;
        _ = _29;
        _ = _30;
        _ = _31;
    }

    public uint this[int index]
    {
        get
        {
            if ((uint)index >= 32)
                throw new IndexOutOfRangeException();

            ref uint firstElement = ref _0;
            return Unsafe.Add(ref firstElement, index);
        }
        set
        {
            if ((uint)index >= 32)
                throw new IndexOutOfRangeException();

            ref uint firstElement = ref _0;
            Unsafe.Add(ref firstElement, index) = value;
        }
    }

    public override bool Equals(object? obj)
    {
        return obj is Container32UInt32 actual && Equals(actual);
    }

    public bool Equals(Container32UInt32 other)
    {
        return
        _0 == other._0 &&
        _1 == other._1 &&
        _2 == other._2 &&
        _3 == other._3 &&
        _4 == other._4 &&
        _5 == other._5 &&
        _6 == other._6 &&
        _7 == other._7 &&
        _8 == other._8 &&
        _9 == other._9 &&
        _10 == other._10 &&
        _11 == other._11 &&
        _12 == other._12 &&
        _13 == other._13 &&
        _14 == other._14 &&
        _15 == other._15 &&
        _16 == other._16 &&
        _17 == other._17 &&
        _18 == other._18 &&
        _19 == other._19 &&
        _20 == other._20 &&
        _21 == other._21 &&
        _22 == other._22 &&
        _23 == other._23 &&
        _24 == other._24 &&
        _25 == other._25 &&
        _26 == other._26 &&
        _27 == other._27 &&
        _28 == other._28 &&
        _29 == other._29 &&
        _30 == other._30 &&
        _31 == other._31 &&
        true;
    }

    public override int GetHashCode()
    {
        HashCode hash = new HashCode();
        hash.Add(_0);
        hash.Add(_1);
        hash.Add(_2);
        hash.Add(_3);
        hash.Add(_4);
        hash.Add(_5);
        hash.Add(_6);
        hash.Add(_7);
        hash.Add(_8);
        hash.Add(_9);
        hash.Add(_10);
        hash.Add(_11);
        hash.Add(_12);
        hash.Add(_13);
        hash.Add(_14);
        hash.Add(_15);
        hash.Add(_16);
        hash.Add(_17);
        hash.Add(_18);
        hash.Add(_19);
        hash.Add(_20);
        hash.Add(_21);
        hash.Add(_22);
        hash.Add(_23);
        hash.Add(_24);
        hash.Add(_25);
        hash.Add(_26);
        hash.Add(_27);
        hash.Add(_28);
        hash.Add(_29);
        hash.Add(_30);
        hash.Add(_31);
        return hash.ToHashCode();
    }

    public static bool operator ==(Container32UInt32 left, Container32UInt32 right)
    {
        return left.Equals(right);
    }

    public static bool operator !=(Container32UInt32 left, Container32UInt32 right)
    {
        return !(left == right);
    }
}

