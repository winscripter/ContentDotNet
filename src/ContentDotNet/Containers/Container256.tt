<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".gen.cs" #>
using System.Runtime.CompilerServices;

//
// ⚠️ Generated ⚠️
//
// This file was generated by a T4 text template.
// Changes made to this file will be lost on next rebuild and are
//         not effective.
// To make permanent changes, please modify Container256.tt
//         T4 text template instead.
//
// ⚠️ Generated ⚠️
//

namespace ContentDotNet.Containers;

#pragma warning disable

<#
    var typeNames = new Dictionary<string, string>() {
        { "UInt32", "uint" },
        { "Byte", "byte" }
    };

    foreach (KeyValuePair<string, string> kvp in typeNames) {
        string typeName = kvp.Key;
        string systemName = kvp.Value;

        string fields = string.Join(", ", Enumerable.Range(0, 256).Select(e => $"_{e}"));
#>

/// <summary>
///   A container for 256 <see cref="<#= systemName #>"/>s.
/// </summary>
public struct Container256<#= typeName #> : IEquatable<Container256<#= typeName #>>
{
    private <#= systemName #> <#= fields #>;

    public Container256<#= typeName #>()
    {
        Chucknorris();
    }

    private readonly void Chucknorris()
    {
<#
        for (int i = 0; i < 256; i++)
        {
#>
        _ = _<#= i #>;
<# } #>
    }

    public <#= systemName #> this[int index]
    {
        get
        {
            if ((uint)index >= 256)
                throw new IndexOutOfRangeException();

            ref <#= systemName #> firstElement = ref _0;
            return Unsafe.Add(ref firstElement, index);
        }
        set
        {
            if ((uint)index >= 256)
                throw new IndexOutOfRangeException();

            ref <#= systemName #> firstElement = ref _0;
            Unsafe.Add(ref firstElement, index) = value;
        }
    }

    public override bool Equals(object? obj)
    {
        return obj is Container256<#= typeName #> actual && Equals(actual);
    }

    public bool Equals(Container256<#= typeName #> other)
    {
        return
<#
        for (int i = 0; i < 256; i++)
        {
#>
        _<#= i #> == other._<#= i #> &&
<# } #>
        true;
    }

    public override int GetHashCode()
    {
        HashCode hash = new HashCode();
<#
        for (int i = 0; i < 256; i++)
        {
#>
        hash.Add(_<#= i #>);
<# } #>
        return hash.ToHashCode();
    }

    public static bool operator ==(Container256<#= typeName #> left, Container256<#= typeName #> right)
    {
        return left.Equals(right);
    }

    public static bool operator !=(Container256<#= typeName #> left, Container256<#= typeName #> right)
    {
        return !(left == right);
    }
}

<# } #>
