<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".gen.cs" #>
using ContentDotNet.Extensions.H264.Models;
using System.Runtime.CompilerServices;

//
// ⚠️ Generated ⚠️
//
// This file was generated by a T4 text template.
// Changes made to this file will be lost on next rebuild and are
//         not effective.
// To make permanent changes, please modify CabacCavlcContainer32.tt
//         T4 text template instead.
//
// ⚠️ Generated ⚠️
//

namespace ContentDotNet.Extensions.H264.Containers;

#pragma warning disable

<#
    var typeNames = new Dictionary<string, string>() {
        { "CabacResidual", "CabacResidual" },
        { "CavlcResidual", "CavlcResidual" },
        { "DecRefPicMarkingEntry", "DecRefPicMarkingEntry" },
        { "RefPicListModificationEntry", "RefPicListModificationEntry" },
        { "RefPicListMvcModificationEntry", "RefPicListMvcModificationEntry" }
    };

    foreach (KeyValuePair<string, string> kvp in typeNames) {
        string typeName = kvp.Key;
        string systemName = kvp.Value;

        string fields = string.Join(", ", Enumerable.Range(0, 32).Select(e => $"_{e}"));
#>

/// <summary>
///   A container for 32 <see cref="<#= systemName #>"/>s.
/// </summary>
public struct Container32<#= typeName #> : IEquatable<Container32<#= typeName #>>
{
    private <#= systemName #> <#= fields #>;

    public Container32<#= typeName #>()
    {
        Chucknorris();
    }

    private readonly void Chucknorris()
    {
<#
        for (int i = 0; i < 32; i++)
        {
#>
        _ = _<#= i #>;
<# } #>
    }

    public <#= systemName #> this[int index]
    {
        get
        {
            if ((uint)index >= 32)
                throw new IndexOutOfRangeException();

            ref <#= systemName #> firstElement = ref _0;
            return Unsafe.Add(ref firstElement, index);
        }
        set
        {
            if ((uint)index >= 32)
                throw new IndexOutOfRangeException();

            ref <#= systemName #> firstElement = ref _0;
            Unsafe.Add(ref firstElement, index) = value;
        }
    }

    public override bool Equals(object? obj)
    {
        return obj is Container32<#= typeName #> actual && Equals(actual);
    }

    public bool Equals(Container32<#= typeName #> other)
    {
        return
<#
        for (int i = 0; i < 32; i++)
        {
#>
        _<#= i #> == other._<#= i #> &&
<# } #>
        true;
    }

    public override int GetHashCode()
    {
        HashCode hash = new HashCode();
<#
        for (int i = 0; i < 32; i++)
        {
#>
        hash.Add(_<#= i #>);
<# } #>
        return hash.ToHashCode();
    }

    public static bool operator ==(Container32<#= typeName #> left, Container32<#= typeName #> right)
    {
        return left.Equals(right);
    }

    public static bool operator !=(Container32<#= typeName #> left, Container32<#= typeName #> right)
    {
        return !(left == right);
    }
}

<# } #>
