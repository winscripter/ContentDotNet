<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Threading" #>
<#@ output extension=".g.cs" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

namespace ContentDotNet.Extensions.Video.H264.Utilities
{
	using ContentDotNet.Extensions.Video.H264.RbspModels;

	<#
		// SPS
		SPS_U("profile_idc");
		for (int i = 0; i < 6; i++)
			SPS_B($"constraint_set{i}_flag");
		SPS_U("reserved_zero_2bits");
		SPS_U("level_idc");
		SPS_U("seq_parameter_set_id");
		SPS_U("chroma_format_idc");
		SPS_B("separate_colour_plane_flag");
		SPS_U("bit_depth_luma_minus8");
		SPS_U("bit_depth_chroma_minus8");
		SPS_B("qpprime_y_zero_transform_bypass_flag");
		SPS_B("seq_scaling_matrix_present_flag");
		SPS_SB("seq_scaling_list_present_flag");
		SPS_U("log2_max_frame_num_minus4");
		SPS_U("pic_order_cnt_type");
		SPS_U("log2_max_pic_order_cnt_lsb_minus4");
		SPS_B("delta_pic_order_always_zero_flag");
		SPS_I("offset_for_non_ref_pic");
		SPS_I("offset_for_top_to_bottom_field");
		SPS_U("num_ref_frames_in_pic_order_cnt_cycle");
		SPS_SI("offset_for_ref_frame");
		SPS_U("max_num_ref_frames");
		SPS_B("gaps_in_frame_num_value_allowed_flag");
		SPS_U("pic_width_in_mbs_minus1");
		SPS_U("pic_height_in_map_units_minus1");
		SPS_B("frame_mbs_only_flag");
		SPS_B("mb_adaptive_frame_field_flag");
		SPS_B("direct_8x8_inference_flag");
		SPS_B("frame_cropping_flag");
		SPS_U("frame_crop_left_offset");
		SPS_U("frame_crop_right_offset");
		SPS_U("frame_crop_top_offset");
		SPS_U("frame_crop_bottom_offset");
		SPS_B("vui_parameters_present_flag");

		// PPS
		PPS_U("pic_parameter_set_id");
		PPS_U("seq_parameter_set_id");
		PPS_B("entropy_coding_mode_flag");
		PPS_B("bottom_field_pic_order_in_frame_present_flag");
		PPS_U("num_slice_groups_minus1");
		PPS_U("slice_group_map_type");
		PPS_SU("run_length_minus1");
		PPS_SU("top_left");
		PPS_SU("bottom_right");
		PPS_B("slice_group_change_direction_flag");
		PPS_U("slice_group_change_rate_minus1");
		PPS_U("pic_size_in_map_units_minus1");
		PPS_SU("slice_group_id");
		PPS_U("num_ref_idx_l0_default_active_minus1");
		PPS_U("num_ref_idx_l1_default_active_minus1");
		PPS_B("weighted_pred_flag");
		PPS_U("weighted_bipred_idc");
		PPS_I("pic_init_qp_minus26");
		PPS_I("pic_init_qs_minus26");
		PPS_I("chroma_qp_index_offset");
		PPS_B("deblocking_filter_control_present_flag");
		PPS_B("constrained_intra_pred_flag");
		PPS_B("redundant_pic_cnt_present_flag");
		PPS_B("transform_8x8_mode_flag");
		PPS_B("pic_scaling_matrix_present_flag");
		PPS_SB("pic_scaling_list_present_flag");
		PPS_I("second_chroma_qp_index_offset");

		// Slice Header
		SHdr_U("first_mb_in_slice");
		SHdr_U("slice_type");
		SHdr_U("pic_parameter_set_id");
		SHdr_U("colour_plane_id");
		SHdr_U("frame_num");
		SHdr_B("field_pic_flag");
		SHdr_B("bottom_field_flag");
		SHdr_U("idr_pic_id");
		SHdr_U("pic_order_cnt_lsb");
		SHdr_I("delta_pic_order_cnt_bottom");
		SHdr_SI("delta_pic_order_cnt");
		SHdr_U("redundant_pic_cnt");
		SHdr_B("direct_spatial_mv_pred_flag");
		SHdr_B("num_ref_idx_active_override_flag");
		SHdr_U("num_ref_idx_l0_active_minus1");
		SHdr_U("num_ref_idx_l1_active_minus1");
		SHdr_U("cabac_init_idc");
		SHdr_I("slice_qp_delta");
		SHdr_B("sp_for_switch_flag");
		SHdr_I("slice_qs_delta");
		SHdr_U("disable_deblocking_filter_idc");
		SHdr_I("slice_alpha_c0_offset_div2");
		SHdr_I("slice_beta_offset_div2");
		SHdr_U("slice_group_change_cycle");
	#>

	/// <summary>
	///   A single, centralized location to grab H.264 syntax elements very easily.
	/// </summary>
	/// <remarks>
	///   <para>The methods that prefix with <c>Fetch</c> will fetch the value and return <see langword="null" /> if it's not available.</para>
	///   <para>The methods that prefix with <c>TryFetch</c> return a boolean indicating if the element was fetched, and the actually fetched element is in an <see langword="out" /> parameter.</para>
	///   <para>The methods that prefix with <c>Get</c> will return an exception if the value is missing, and if these methods do return, they guarantee to return non-nullable values.</para>
	/// </remarks>
	public static class SyntaxElementGrabber
	{
		<#
			foreach (KeyValuePair<string, Item> kvp in _db)
			{
				Item item = kvp.Value;
				string fieldNamePascalCase = ToPascalCaseFromSnakeCase(kvp.Key);
				if (fieldNamePascalCase == "Transform8X8ModeFlag")
					fieldNamePascalCase = "Transform8x8ModeFlag";
				else if (fieldNamePascalCase == "WeightedBipredIdc")
					fieldNamePascalCase = "WeightedBiPredIdc";
				else if (fieldNamePascalCase == "Direct8X8InferenceFlag")
					fieldNamePascalCase = "Direct8x8InferenceFlag";
				string reference = $@"<see cref=""H264RbspState.{item.InnerType}"" />, and from there, <see cref=""Rbsp{item.InnerType}.{fieldNamePascalCase}"" />";
		#>

		#region Derivative for <#= kvp.Key #>

		/// <summary>
		///   Retrieves <#= reference #> from <paramref name="state" /> or returns
		///   <see langword="null" /> if <paramref name="state" />, <see cref="H264RbspState.<#= item.InnerType #>" />, or
		///   <#= reference #> is <see langword="null" />.
		/// </summary>
		/// <param name="state">The source H.264 RBSP state</param>
		/// <returns><#= reference #>, or <see langword="null" /> if unavailable.</returns>
		public static <#= item.ReturnType #>? Fetch<#= fieldNamePascalCase #>(H264RbspState? state)
		{
			if (state is null) return null;
			if (state.<#= item.InnerType #> is null) return null;
			var value = state.<#= item.InnerType #>.<#= fieldNamePascalCase #>;
			return value;
		}

		/// <summary>
		///   Attempts to retrieve <#= reference #> from <paramref name="state" />. If successful, the return value is <see langword="true" /> and the
		///   output value is placed into <paramref name="result" />. When the return value is <see langword="false" />, <paramref name="result" />
		///   will be <see langword="null" />, and it indicates that fetching the value failed.
		/// </summary>
		/// <param name="state">The source H.264 RBSP state</param>
		/// <param name="result">The resulting <#= reference #> is stored here if the return value is <see langword="true" />.</param>
		/// <returns>A boolean indicating if the value was successfully fetched (true). If so, <paramref name="result" /> contains the resulting RBSP element. Otherwise, it is set equal to <see langword="null" />.</returns>
		public static bool TryFetch<#= fieldNamePascalCase #>(H264RbspState? state, out <#= item.ReturnType #>? result)
		{
			result = Fetch<#= fieldNamePascalCase #>(state);
			return result is not null;
		}

		/// <summary>
		///   💥 Forces <#= reference #> from <paramref name="state" /> to be fetched. If it can't be fetched, an <see cref="InvalidOperationException" /> exception
		///    is thrown. The returned value is guaranteed to never be <see langword="null" />.
		/// </summary>
		/// <param name="state">The source H.264 RBSP state</param>
		/// <returns>A returned value of type <#= reference #>. It is guaranteed to never be <see langword="null" />.</returns>
		/// <exception cref="InvalidOperationException">Thrown if the value cannot be fetched.</exception>
		public static <#= item.ReturnType #> Get<#= fieldNamePascalCase #>(H264RbspState? state)
		{
			if (!TryFetch<#= fieldNamePascalCase #>(state, out var result))
				throw new InvalidOperationException("The value <#= fieldNamePascalCase #> could not be fetched.");
			return result!<#= item.IsValueType ? ".Value" : "" #>;
		}

		#endregion

		<# } #>
	}
}

<#+
private class Item
{
	public string ReturnType { get; }
	public string InnerType { get; }
	public bool IsValueType { get; }

	public Item(string returnType, string[] ways, bool isValueType)
	{
		ReturnType = returnType;
		InnerType = ways[0];
		IsValueType = isValueType;
	}
}

private readonly Dictionary<string, Item> _db = new Dictionary<string, Item>();

private void SPS_U(string field)
{
	_db[field] = new Item("uint", new[] { "SequenceParameterSetData" }, true);
}

private void SPS_B(string field)
{
	_db[field] = new Item("bool", new[] { "SequenceParameterSetData" }, true);
}

private void SPS_I(string field)
{
	_db[field] = new Item("int", new[] { "SequenceParameterSetData" }, true);
}

private void SPS_SB(string field)
{
	_db[field] = new Item("bool[]", new[] { "SequenceParameterSetData" }, false);
}

private void SPS_SU(string field)
{
	_db[field] = new Item("uint[]", new[] { "SequenceParameterSetData" }, false);
}

private void SPS_SI(string field)
{
	_db[field] = new Item("int[]", new[] { "SequenceParameterSetData" }, false);
}



private void PPS_U(string field)
{
	_db[field] = new Item("uint", new[] { "PictureParameterSet" }, true);
}

private void PPS_B(string field)
{
	_db[field] = new Item("bool", new[] { "PictureParameterSet" }, true);
}

private void PPS_I(string field)
{
	_db[field] = new Item("int", new[] { "PictureParameterSet" }, true);
}

private void PPS_SB(string field)
{
	_db[field] = new Item("bool[]", new[] { "PictureParameterSet" }, false);
}

private void PPS_SU(string field)
{
	_db[field] = new Item("uint[]", new[] { "PictureParameterSet" }, false);
}



private void SHdr_U(string field)
{
	_db[field] = new Item("uint", new[] { "SliceHeader" }, true);
}

private void SHdr_B(string field)
{
	_db[field] = new Item("bool", new[] { "SliceHeader" }, true);
}

private void SHdr_I(string field)
{
	_db[field] = new Item("int", new[] { "SliceHeader" }, true);
}

private void SHdr_SB(string field)
{
	_db[field] = new Item("bool[]", new[] { "SliceHeader" }, false);
}

private void SHdr_SU(string field)
{
	_db[field] = new Item("uint[]", new[] { "SliceHeader" }, false);
}

private void SHdr_SI(string field)
{
	_db[field] = new Item("int[]", new[] { "SliceHeader" }, false);
}

private static string ToPascalCaseFromSnakeCase(string snake_case_string)
{
	return string.Concat(
        snake_case_string.Split('_')
        .Select(Thread.CurrentThread.CurrentCulture.TextInfo.ToTitleCase)
    );
}
#>
