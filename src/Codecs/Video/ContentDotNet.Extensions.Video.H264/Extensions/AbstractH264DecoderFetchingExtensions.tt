<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".g.cs" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

namespace ContentDotNet.Extensions.Video.H264.Extensions
{
	using ContentDotNet.Extensions.Video.H264.RbspModels;

	/// <summary>
	///   These are extensions that fetch syntax values off of <see cref="AbstractH264Decoder" />.
	/// </summary>
	/// <remarks>
	///   <para>The methods that prefix with <c>Fetch</c> will fetch the value and return <see langword="null" /> if it's not available.</para>
	///   <para>The methods that prefix with <c>TryFetch</c> return a boolean indicating if the element was fetched, and the actually fetched element is in an <see langword="out" /> parameter.</para>
	///   <para>The methods that prefix with <c>Get</c> will return an exception if the value is missing, and if these methods do return, they guarantee to return non-nullable values.</para>
	/// </remarks>
	public static class AbstractH264DecoderFetchingExtensions
	{
		<#
			var map = new Dictionary<string, (string retType, string code)>()
			{
				["Sps"] = ("RbspSequenceParameterSetData", "decoder.State?.H264RbspState?.SequenceParameterSetData"),
				["Vui"] = ("RbspVuiParameters", "decoder.State?.H264RbspState?.SequenceParameterSetData?.VuiParameters"),
				["NalHrd"] = ("RbspHrdParameters", "decoder.State?.H264RbspState?.SequenceParameterSetData?.VuiParameters?.NalHrdParameters"),
				["VclHrd"] = ("RbspHrdParameters", "decoder.State?.H264RbspState?.SequenceParameterSetData?.VuiParameters?.VclHrdParameters"),
				["Aud"] = ("RbspAccessUnitDelimiter", "decoder.State?.H264RbspState?.AccessUnitDelimiter"),
				["SliceHeader"] = ("RbspSliceHeader", "decoder.State?.H264RbspState?.SliceHeader"),
				["DecRefPicMarking"] = ("RbspDecRefPicMarking", "decoder.State?.H264RbspState?.SliceHeader?.DecRefPicMarking"),
				["DecodedReferencePictureMarking"] = ("RbspDecRefPicMarking", "decoder.State?.H264RbspState?.SliceHeader?.DecRefPicMarking"),
				["PredWeightTable"] = ("RbspPredWeightTable", "decoder.State?.H264RbspState?.SliceHeader?.PredWeightTable"),
				["PredictionWeightTable"] = ("RbspPredWeightTable", "decoder.State?.H264RbspState?.SliceHeader?.PredWeightTable"),
				["Pps"] = ("RbspPictureParameterSet", "decoder.State?.H264RbspState?.PictureParameterSet"),
				["RefPicListModification"] = ("RbspRefPicListModification", "decoder.State?.H264RbspState?.SliceHeader?.RefPicListModification"),
				["ReferencePictureListModification"] = ("RbspRefPicListModification", "decoder.State?.H264RbspState?.SliceHeader?.RefPicListModification"),
				["RefPicListMvcModification"] = ("MvcRbspRefPicListMvcModification", "decoder.State?.H264RbspState?.SliceHeader?.RefPicListMvcModification"),
				["ReferencePictureListMvcModification"] = ("MvcRbspRefPicListMvcModification", "decoder.State?.H264RbspState?.SliceHeader?.RefPicListMvcModification"),
			};
			foreach (var value in map)
			{
		#>

		/// <summary>
		///   Retrieves <see cref="<#= value.Value.retType #>" />, or returns <see langword="null" /> if that value isn't available or the
		///   H.264 state/RBSP state is missing.
		/// </summary>
		/// <param name="decoder">The source H.264 decoder</param>
		/// <returns><see cref="<#= value.Value.retType #>" />, or <see langword="null" /> if unavailable.</returns>
		public static <#= value.Value.retType #>? Fetch<#= value.Key #>(this AbstractH264Decoder decoder)
		{
			return <#= value.Value.code #>;
		}

		/// <summary>
		///   Attempts to retrieve <see cref="<#= value.Value.retType #>" />. If successful, the return value is <see langword="true" /> and the
		///   output value is placed into <paramref name="result" />. When the return value is <see langword="false" />, <paramref name="result" />
		///   will be <see langword="null" />, and it indicates that fetching the value failed.
		/// </summary>
		/// <param name="decoder">The source H.264 decoder</param>
		/// <param name="result">The resulting <see cref="<#= value.Value.retType #>" /> is stored here if the return value is <see langword="true" />.</param>
		/// <returns>A boolean indicating if the value was successfully fetched (true). If so, <paramref name="result" /> contains the resulting RBSP element. Otherwise, it is set equal to <see langword="null" />.</returns>
		public static bool TryFetch<#= value.Key #>(this AbstractH264Decoder decoder, out <#= value.Value.retType #>? result)
		{
			result = <#= value.Value.code #>;
			return result is not null;
		}

		/// <summary>
		///   💥 Forces <see cref="<#= value.Value.retType #>" /> to be fetched. If it can't be fetched, an <see cref="InvalidOperationException" /> exception
		///    is thrown. The returned value is guaranteed to never be <see langword="null" />.
		/// </summary>
		/// <param name="decoder">The source H.264 decoder</param>
		/// <returns>A returned value of type <see cref="<#= value.Value.retType #>" />. It is guaranteed to never be <see langword="null" />.</returns>
		/// <exception cref="InvalidOperationException">Thrown if the value cannot be fetched.</exception>
		public static <#= value.Value.retType #> Get<#= value.Key #>(this AbstractH264Decoder decoder)
		{
			if (!decoder.TryFetch<#= value.Key #>(out var result))
				throw new InvalidOperationException("The value <#= value.Value.retType #> could not be fetched.");
			return result!;
		}
		<# } #>
	}
}
