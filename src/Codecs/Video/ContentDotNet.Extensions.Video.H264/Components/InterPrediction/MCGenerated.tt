<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".g.cs" #>
namespace ContentDotNet.Extensions.Video.H264.Components.InterPrediction
{
    using ContentDotNet.Colors;
    using ContentDotNet.Extensions.Video.H264.Components.Common;
    using ContentDotNet.Pictures;

    public static partial class MotionCompensation
    {
        private static void Generated_InterpolateLumaSample(
            int xIntL,
            int yIntL,
            int xFracL,
            int yFracL,
            int xL,
            int yL,
            int PicHeightInSamplesL,
            int PicWidthInSamplesL,
            bool MbaffFrameFlag,
            bool mb_field_decoding_flag,
            int BitDepthY,
            Picture<YCbCr> refPicLX,
            Picture<YCbCr> predPartLX,
            Func<YCbCr, int, YCbCr> mutateChannel)
        {
            int refPicHeightEffectiveL = !MbaffFrameFlag || !mb_field_decoding_flag ? PicHeightInSamplesL : PicHeightInSamplesL / 2;

            <#
                for (int i = 'A'; i <= 'U'; i++)
                {
            #>

            int xD<#= (char)i #>L = XDzl[<#= (int)(i - 'A') #>];
            int yD<#= (char)i #>L = YDzl[<#= (int)(i - 'A') #>];
            int x<#= (char)i #>L = Clipping.Clip(0, PicWidthInSamplesL - 1, xIntL + xD<#= (char)i #>L);
            int y<#= (char)i #>L = Clipping.Clip(0, refPicHeightEffectiveL - 1, yIntL + yD<#= (char)i #>L);
            int <#= (char)i #> = refPicLX[x<#= (char)i #>L, y<#= (char)i #>L].Y;
            <# } #>

            <#
                var middle = new Dictionary<string, (char, char)>() {
                    ["cc"] = ('E', 'K'),
                    ["dd"] = ('F', 'L'),
                    ["aa"] = ('A', 'B'),
                    ["bb"] = ('C', 'D'),
                    ["ee"] = ('I', 'P'),
                    ["ff"] = ('J', 'Q'),
                    ["gg"] = ('R', 'S'),
                    ["hh"] = ('T', 'U')
                };

                foreach (KeyValuePair<string, (char, char)> kvp in middle) {
            #>
            int <#= kvp.Key #> = CommonFunctions.Middle(<#= kvp.Value.Item1 #>, <#= kvp.Value.Item2 #>);
            <# } #>

            int m1 = K - 5 * L + 20 * M + 20 * N - 5 * P + Q;
            int s1 = B - 5 * D + 20 * H + 20 * N - 5 * S + U;
            int b1 = (E - 5 * F + 20 * G + 20 * H - 5 * I + J);
            int h1 = (A - 5 * C + 20 * G + 20 * M - 5 * R + T);

            int b = Clipping.Clip1Y((b1 + 16) >> 5, BitDepthY);
            int h = Clipping.Clip1Y((h1 + 16) >> 5, BitDepthY);

            int j1 = cc - 5 * dd + 20 * h1 + 20 * m1 - 5 * ee + ff;

            int j = Clipping.Clip1Y((j1 + 512) >> 10, BitDepthY);

            int s = Clipping.Clip1Y((s1 + 16) >> 5, BitDepthY);   
            int m = Clipping.Clip1Y((m1 + 16) >> 5, BitDepthY);

            int a = (G + b + 1) >> 1;
            int c = (H + b + 1) >> 1;
            int d = (G + h + 1) >> 1;
            int n = (M + h + 1) >> 1;
            int f = (b + j + 1) >> 1;
            int i = (h + j + 1) >> 1;
            int k = (j + m + 1) >> 1;
            int q = (j + s + 1) >> 1;

            int e = (b + h + 1) >> 1;
            int g = (b + m + 1) >> 1;
            int p = (h + s + 1) >> 1;
            int r = (m + s + 1) >> 1;

            var predPart = predPartLX[xL, yL];
            predPart = mutateChannel(predPart, (xFracL, yFracL) switch
            {
                (0, 0) => (byte)G,
                (0, 1) => (byte)d,
                (0, 2) => (byte)h,
                (0, 3) => (byte)n,
                (1, 0) => (byte)a,
                (1, 1) => (byte)e,
                (1, 2) => (byte)i,
                (1, 3) => (byte)p,
                (2, 0) => (byte)b,
                (2, 1) => (byte)f,
                (2, 2) => (byte)j,
                (2, 3) => (byte)q,
                (3, 0) => (byte)c,
                (3, 1) => (byte)g,
                (3, 2) => (byte)k,
                (3, 3) => (byte)r,
                _ => throw new InvalidOperationException("xFracL and yFracL may only range from 0 to 3")
            });
            predPartLX[xL, yL] = predPart;
        }
    }
}
