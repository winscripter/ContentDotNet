<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Globalization" #>
<#@ output extension=".g.cs" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

<#
	const int Int32 = 2;
	const int Boolean = 1;
	const int UInt32 = 0;

	// string - raw H.264 name
	// bool - 2 = signed integer value, 1 = boolean value, 0 = unsigned integer value
	var seCABAC = new Dictionary<string, int>()
	{
		["end_of_slice_flag"] = Boolean,
		["coded_block_flag"] = Boolean,
		["significant_coeff_flag"] = Boolean,
		["last_significant_coeff_flag"] = Boolean,
		["coeff_abs_level_minus1"] = UInt32,
		["coeff_sign_flag"] = Boolean,
		["coeff_abs_level_minus1"] = UInt32,
		["coeff_sign_flag"] = Boolean
	};

	// string - raw H.264 name
	// bool - 2 = signed integer value, 1 = boolean value, 0 = unsigned integer value
	var seCAVLC = new Dictionary<string, int>()
	{
		["mb_skip_run"] = UInt32,
		["mb_skip_flag"] = Boolean,
		["coeff_token"] = UInt32,
		["trailing_ones_sign_flag"] = Boolean,
		["level_prefix"] = UInt32,
		["level_suffix"] = UInt32,
		["total_zeros"] = UInt32,
		["run_before"] = UInt32
	};

	// string - raw H.264 name
	// bool - 2 = signed integer value, 1 = boolean value, 0 = unsigned integer value
	var seVals = new Dictionary<string, int>()
	{
		["mb_skip_run"] = UInt32,
		["mb_skip_flag"] = Boolean,
		["mb_field_decoding_flag"] = Boolean,
		["end_of_slice_flag"] = Boolean,
		["mb_type"] = UInt32,
		["transform_size_8x8_flag"] = Boolean,
		["coded_block_pattern"] = UInt32,
		["mb_qp_delta"] = Int32,
		["prev_intra4x4_pred_mode_flag"] = Boolean,
		["rem_intra4x4_pred_mode"] = UInt32,
		["prev_intra8x8_pred_mode_flag"] = Boolean,
		["rem_intra8x8_pred_mode"] = UInt32,
		["intra_chroma_pred_mode"] = UInt32,
		["ref_idx_l0"] = UInt32,
		["ref_idx_l1"] = UInt32,
		["mvd_l0"] = Int32,
		["mvd_l1"] = Int32,
		["sub_mb_type"] = UInt32,
		["coeff_token"] = UInt32,
		["trailing_ones_sign_flag"] = Boolean,
		["level_prefix"] = UInt32,
		["level_suffix"] = UInt32,
		["total_zeros"] = UInt32,
		["run_before"] = UInt32,
		["coded_block_flag"] = Boolean,
		["significant_coeff_flag"] = Boolean,
		["last_significant_coeff_flag"] = Boolean,
		["coeff_abs_level_minus1"] = UInt32,
		["coeff_sign_flag"] = Boolean,
		["coeff_abs_level_minus1"] = UInt32,
		["coeff_sign_flag"] = Boolean
	};
#>
namespace ContentDotNet.Extensions.Video.H264.Components.IO.Presets
{
	internal abstract class StrictlyCabacReader : H264ReaderBase
	{
		public override bool UsesCabac => true;

	<#
		foreach (KeyValuePair<string, int> val in seVals) {
			string csType = val.Value switch {
				UInt32 => "uint",
				Boolean => "bool",
				Int32 => "int",
				_ => string.Empty
			};
			string csName = val.Key.ToLower().Replace("_", " ");
			TextInfo info = CultureInfo.CurrentCulture.TextInfo;
			csName = info.ToTitleCase(csName).Replace(" ", string.Empty);
			bool includeError = seCAVLC.ContainsKey(val.Key);
			if (includeError) {
	#>
public override <#= csType #> Read<#= csName #>()
		{
			StrictThrowHelper.ThrowCavlcOnCabac();
			return default;
		}

		public override Task<<#= csType #>> Read<#= csName #>Async()
		{
			StrictThrowHelper.ThrowCavlcOnCabac();
			return Task.FromResult<<#= csType #>>(default);
		}

	<# } #>
	<# } #>
	}

	internal abstract class StrictlyCavlcReader : H264ReaderBase
	{
		public override bool UsesCabac => false;
	<#
		foreach (KeyValuePair<string, int> val in seVals) {
			string csType = val.Value switch {
				UInt32 => "uint",
				Boolean => "bool",
				Int32 => "int",
				_ => string.Empty
			};
			string csName = val.Key.ToLower().Replace("_", " ");
			TextInfo info = CultureInfo.CurrentCulture.TextInfo;
			csName = info.ToTitleCase(csName).Replace(" ", string.Empty);
			bool includeError = seCABAC.ContainsKey(val.Key);
			if (includeError) {
	#>
public override <#= csType #> Read<#= csName #>()
		{
			StrictThrowHelper.ThrowCabacOnCavlc();
			return default;
		}

		public override Task<<#= csType #>> Read<#= csName #>Async()
		{
			StrictThrowHelper.ThrowCavlcOnCabac();
			return Task.FromResult<<#= csType #>>(default);
		}

	<# } #>
	<# } #>
	}
}