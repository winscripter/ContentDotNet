<!DOCTYPE html>
<html>
<head>
    <style>
        textarea {
            resize: horizontal;
        }
        * {
            font-family: 'Comic Sans MS';
            font-weight: 400;
            color: white;
        }
        body, textarea, button, option, select, input {
            background-color: #212134;
            accent-color: #212134;
        }
        #errmsg{
            color: red;
        }
    </style>
    <title>Raw Bytes -> H.264 CABAC encoder</title>
</head>
<body>
    <h1>H.264 CABAC bin writer</h1>
    <p>
        This tool can be used to encode raw H.264 CABAC bins.
        <br /><br />
        Internally, this tool is used to create bytes that resemble source H.264 CABAC-coded data for use in testing
        the arithmetic decoding engine used by ContentDotNet.
        <br /><br />
        This tool can be used by anyone, and is licensed under MIT.
        <br /><br />
        Copyright (c) 2023-2025, winscripter. This file comes from https://github.com/winscripter/ContentDotNet.
    </p>
    <fieldset>
        <legend>Options</legend>
        <input type="checkbox" id="chkValMPS" name="valMPS" /> <label for="valMPS">Initial Most Probable Symbol (valMPS)</label> <br />
        <textarea id="txtPStateIdx" placeholder="Initial pStateIdx (Number only)"></textarea> <br />
        <select id="typeEnc">
            <option selected>Decision</option>
            <option>Bypass</option>
            <option>Terminate</option>
        </select>
    </fieldset>
    <fieldset>
        <legend>Input/output</legend>
        <textarea id="txtInp" placeholder="Input"></textarea>
        <textarea id="txtOut" placeholder="Output" readonly></textarea>
    </fieldset>
    <button onclick="exec()">Run</button>
    <p id="errmsg"></p>

    <script>
        class BitstreamWriter{
            constructor() {
                this.bswDataStorage = [];
                this.bswBitPtr = 0;
            }
            getDataStorage() { return this.bswDataStorage; }
            writeBit(b) {
                if (this.bswBitPtr == 8) {
                    this.bswDataStorage.push(0);
                    this.bswBitPtr = 0;
                }
                if (b) {
                    this.bswDataStorage[this.bswDataStorage.length - 1] |= (1 << this.bswBitPtr);
                }
                this.bswBitPtr++;
            }
        }
        function formatBSWdata(bsw) {
            return bsw.getDataStorage().map(num => {
                let hex = num.toString(16);
                return "0x" + hex.padStart(2, '0');
            }).join(', ');
        }
        const rangeTabLPS = {
            0: [128, 176, 208, 240],
            1: [128, 167, 197, 227],
            2: [128, 158, 187, 216],
            3: [123, 150, 178, 205],
            4: [116, 142, 169, 195],
            5: [111, 135, 160, 185],
            6: [105, 128, 152, 175],
            7: [100, 122, 144, 166],
            8: [95, 116, 137, 158],
            9: [90, 110, 130, 150],
            10: [85, 104, 123, 142],
            11: [81, 99, 117, 135],
            12: [77, 94, 111, 128],
            13: [73, 89, 105, 122],
            14: [69, 85, 100, 116],
            15: [66, 80, 95, 110],
            16: [62, 76, 90, 104],
            17: [59, 72, 86, 99],
            18: [56, 69, 81, 94],
            19: [53, 65, 77, 89],
            20: [51, 62, 73, 85],
            21: [48, 59, 69, 80],
            22: [46, 56, 66, 76],
            23: [43, 53, 63, 72],
            24: [41, 50, 59, 69],
            25: [39, 48, 56, 65],
            26: [37, 45, 54, 62],
            27: [35, 43, 51, 59],
            28: [33, 41, 48, 56],
            29: [32, 39, 46, 53],
            30: [30, 37, 43, 50],
            31: [29, 35, 41, 48],
            32: [27, 33, 39, 45],
            33: [26, 31, 37, 43],
            34: [24, 30, 35, 41],
            35: [23, 28, 33, 39],
            36: [22, 27, 32, 37],
            37: [21, 26, 30, 35],
            38: [20, 24, 29, 33],
            39: [19, 23, 27, 31],
            40: [18, 22, 26, 30],
            41: [17, 21, 25, 28],
            42: [16, 20, 23, 27],
            43: [15, 19, 22, 25],
            44: [14, 18, 21, 24],
            45: [14, 17, 20, 23],
            46: [13, 16, 19, 22],
            47: [12, 15, 18, 21],
            48: [12, 14, 17, 20],
            49: [11, 14, 16, 19],
            50: [11, 13, 15, 18],
            51: [10, 12, 15, 17],
            52: [10, 12, 14, 16],
            53: [9, 11, 13, 15],
            54: [9, 11, 12, 14],
            55: [8, 10, 12, 14],
            56: [8, 9, 11, 13],
            57: [7, 9, 11, 12],
            58: [7, 9, 10, 12],
            59: [7, 8, 10, 11],
            60: [6, 8, 9, 11],
            61: [6, 7, 9, 10],
            62: [6, 7, 8, 9],
            63: [2, 2, 2, 2]
        };
        const transIdxLPS = [
            0,
            0,
            1,
            2,
            2,
            4,
            4,
            5,
            6,
            7,
            8,
            9,
            9,
            11,
            11,
            12,
            13,
            13,
            15,
            15,
            16,
            16,
            18,
            18,
            19,
            19,
            21,
            21,
            22,
            22,
            23,
            24,
            24,
            25,
            26,
            26,
            27,
            27,
            28,
            29,
            29,
            30,
            30,
            30,
            31,
            32,
            32,
            33,
            33,
            33,
            34,
            34,
            35,
            35,
            35,
            36,
            36,
            36,
            37,
            37,
            37,
            38,
            38,
            63
        ];
        const transIdxMPS = [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            62,
            63
        ];
        let CABACBinModes = {
            DECISION: 0,
            BYPASS: 1,
            TERMINATE: 2
        };
        let GlobalCABACBinWriterOptions = {
            valMPS: 1,
            pStateIdx: 0,
            mode: CABACBinModes.DECISION
        };
        class CABACBinWriter {
            constructor(bsw) {
                this.bsw = bsw;

                this.codILow = 0;
                this.codIRange = 510;
                this.firstBitFlag = 1;
                this.bitsOutstanding = 0;
            }
            encode(b) {
                if (GlobalCABACBinWriterOptions.mode == CABACBinModes.DECISION) {
                    this.encodeDecision(b);
                }
                else if (GlobalCABACBinWriterOptions.mode == CABACBinModes.BYPASS) {
                    this.encodeBypass(b);
                }
                else {
                    this.encodeTerminate(b);
                }
            }
            encodeDecision(b) {
                const qCodIRangeIdx = (this.codIRange >> 6) & 3;
                const codIRangeLPS = rangeTabLPS[GlobalCABACBinWriterOptions.pStateIdx][qCodIRangeIdx];
                this.codIRange -= codIRangeLPS;

                if (b != GlobalCABACBinWriterOptions.valMPS) {
                    this.codILow += this.codIRange;
                    if (GlobalCABACBinWriterOptions.pStateIdx != 0) {
                        GlobalCABACBinWriterOptions.valMPS = 1 - GlobalCABACBinWriterOptions.valMPS;
                    }
                    GlobalCABACBinWriterOptions.pStateIdx = transIdxLPS[GlobalCABACBinWriterOptions.pStateIdx];
                }
                else {
                    GlobalCABACBinWriterOptions.pStateIdx = transIdxMPS[GlobalCABACBinWriterOptions.pStateIdx];
                }
                this.renormE();
            }
            renormE() {
                let iterations = 0;
                const MAX_ITER = 150;

                const _codIRange = () => this.codIRange;
                const _codILow = () => this.codILow;
                const __codIRange = (x) => this.codIRange = x;
                const __codILow = (x) => this.codILow = x;
                const _bo = () => this.bitsOutstanding;
                const __bo = (x) => this.bitsOutstanding = x;
                const bsw = () => this.bsw;
                const _fbf = () => this.firstBitFlag;
                const __fbf = (x) => this.firstBitFlag = x;

                const routineStart = () => {
                    if (iterations++ >= MAX_ITER) {
                        throw 'Too many renormalization iterations';
                    }
                    if (_codIRange() < 256) {
                        if (!_codILow() < 256) {
                            if (_codILow() >= 512) {
                                __codILow(_codILow() - 512);
                                this.pb(true);
                            }
                            else {
                                __codILow(_codILow() - 256);
                                __bo(_bo() + 1);
                            }
                        }
                        else {
                            this.pb(false);
                        }
                    }
                    else {
                        return;
                    }
                    __codIRange(_codIRange() << 1);
                    __codILow(_codILow() << 1);

                    routineStart();
                };

                routineStart();
            }
            pb(x) { // PutBit
                if (this.firstBitFlag != 0) {
                    this.firstBitFlag = 0;
                }
                else {
                    this.bsw.writeBit(x);
                }

                const pbRoutineStart = () => {
                    while (this.bitsOutstanding > 0) {
                        this.bsw.writeBit(!x);
                        this.bitsOutstanding--;
                    }
                };

                pbRoutineStart();
            };
            encodeBypass(b) {
                this.codILow <<= 1;
                if (b) {
                    this.codILow += this.codIRange;
                }
                if (this.codILow >= 1024) {
                    this.bsw.writeBit(true);
                    this.codILow -= 1024;
                }
                else {
                    if (this.codILow < 512) {
                        this.bsw.writeBit(false);
                    }
                    else {
                        this.codILow -= 512;
                        this.bitsOutstanding++;
                    }
                }
            }
            encodeTerminate(b) {
                this.codIRange -= 2;
                if (b) {
                    this.codILow += this.codIRange;
                    this.encodeFlush();
                }
                else {
                    this.renormE();
                }
            }
            encodeFlush() {
                this.codIRange = 2;
                this.renormE();
                this.pb(((this.codILow >> 9) & 1) == 1);
                const value2Write = ((this.codILow >> 7) & 3) | 1;
                for (let i = 0; i < 2; i++)
                    this.bsw.writeBit((value2Write & (1 << i)) != 0);
            }
        }
        function $(x) { return document.getElementById(x); }
        const chkValMPS = $("chkValMPS");
        const txtPStateIdx = $("txtPStateIdx");
        const typeEnc = $("typeEnc");
        const txtInp = $("txtInp");
        const txtOut = $("txtOut");
        const errmsg = $("errmsg");
        function loadSettings() {
            GlobalCABACBinWriterOptions.valMPS = chkValMPS.checked ? 1 : 0;
            GlobalCABACBinWriterOptions.pStateIdx = parseInt(txtPStateIdx.value);
        }
        function parseBytes(input) {
            const tokens = input.split(' ');
            const bytes = tokens.flatMap(token => {
                let value;
                if (token.startsWith("0x")) { value = parseInt(token, 16); }
                else if (token.startsWith("0b")) { value = parseInt(token, 2); }
                else { throw new Error(`Unknown format: ${token}`); }
                const byteArray = [];
                while (value > 0) {
                    byteArray.unshift(value & 0xff);
                    value >>= 8;
                }
                return byteArray;
            });
            return bytes;
        }
        function execCore() {
            loadSettings();
            switch (typeEnc.value) {
                case "Decision": GlobalCABACBinWriterOptions.mode = CABACBinModes.DECISION; break;
                case "Terminate": GlobalCABACBinWriterOptions.mode = CABACBinModes.TERMINATE; break;
                case "Bypass": GlobalCABACBinWriterOptions.mode = CABACBinModes.BYPASS; break;
            }
            const bytes = parseBytes(txtInp.value);
            const bsw = new BitstreamWriter();
            const cabacEnc = new CABACBinWriter(bsw);
            for (let i = 0; i < bytes.length; i++) {
                for (let j = 0; j < 8; j++) {
                    cabacEnc.encode((bytes[i] & (1 << j)) != 0);
                }
            }
            txtOut.value = formatBSWdata(bsw);
        }
        function exec() {
            try {
                execCore();
            } catch (ex) {
                errmsg.innerHTML = `Uh-oh! An error occurred.

${ex}`;
            }
        }
    </script>
</body>
</html>
