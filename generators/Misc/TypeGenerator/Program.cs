namespace ContentDotNet.SourceGenerator.Types
{
    using System.CodeDom.Compiler;
    using System.Text.Json;
    using System.Text.Json.Serialization;

    internal class JTypeDescriptor
    {
        [JsonPropertyName("specification")]
        public string Specification { get; set; } = "int A";

        [JsonPropertyName("documentation")]
        public string Documentation { get; set; } = "Just a property";
    }

    internal class JTypeDocument
    {
        [JsonPropertyName("className")]
        public string ClassName { get; set; } = "C";

        [JsonPropertyName("properties")]
        public List<JTypeDescriptor> Properties { get; set; } = [];
    }

    internal class JType
    {
        [JsonPropertyName("namespace")]
        public string Namespace { get; set; } = "N";

        [JsonPropertyName("fileName")]
        public string FileName { get; set; } = "F.generated.cs";

        [JsonPropertyName("types")]
        public List<JTypeDocument> Documents { get; set; } = [];
    }

    internal static class ExitCodes
    {
        public const int JsonFileIsNull = 11;
        public const int NothingToGenerate = 12;
    }

    internal class Program
    {
        private static void Main(string[] args)
        {
            if (args.Length == 0)
            {
                Console.WriteLine("Use this program like this: TypeGenerator <input .types.json file>");
                Console.WriteLine("Output C# file will be placed as specified inside the JSON file.");

                return;
            }

            string inputFile = args[0];

            if (!File.Exists(inputFile))
                throw new FileNotFoundException(inputFile);

            string inputFileContents = File.ReadAllText(inputFile);

            JType? type = JsonSerializer.Deserialize<JType>(inputFileContents);

            if (type == null)
            {
                ExitProgramWithError("input types JSON file has nothing but 'null', or is empty", ExitCodes.JsonFileIsNull);
                return;
            }

            if (type.Documents.Count == 0)
            {
                ExitProgramWithError("there are no types to generate", ExitCodes.JsonFileIsNull);
                return;
            }

            using var outputFileWriter = File.Open(type.FileName, FileMode.Create);
            using var sw = new StreamWriter(outputFileWriter);
            var itw = new IndentedTextWriter(sw);

            itw.WriteLine("/// <auto-generated />");
            itw.WriteLine();
            itw.WriteLine("//");
            itw.WriteLine("// Copyright (c) 2023-2025, winscripter");
            itw.WriteLine("//");
            itw.WriteLine("// File generated by TypeGenerator (see generators/Misc/TypeGenerator)");
            itw.WriteLine($"// on {DateTime.Now}.");
            itw.WriteLine("//");
            itw.WriteLine();
            itw.WriteLine("#nullable enable");
            itw.WriteLine();

            itw.WriteLine($"namespace {type.Namespace}");
            WriteOpenBlock();

            foreach (JTypeDocument document in type.Documents)
            {
                itw.WriteLine($"public partial class {document.ClassName} : IEquatable<{document.ClassName}?>");
                WriteOpenBlock();

                foreach (JTypeDescriptor descriptor in document.Properties)
                {
                    string[] split = descriptor.Specification.Split(' ');
                    string propType = split[0];
                    string propName = split[1];

                    string propNameButCamelCase = FirstCharToLower(propName);

                    itw.WriteLine($"/// <summary>");

                    foreach (string line in descriptor.Documentation.Split([Environment.NewLine], StringSplitOptions.None))
                    {
                        itw.WriteLine($"/// <para>{line}</para>");
                    }

                    itw.WriteLine($"/// </summary>");
                    itw.WriteLine($"/// <remarks>");
                    itw.WriteLine($"///   This property maps to the parameter <c>{propNameButCamelCase}</c> in the constructor.");
                    itw.WriteLine($"/// </remarks>");
                    itw.WriteLine($"public {descriptor.Specification} {{ get; set; }}");
                    itw.WriteLine();
                }

                itw.WriteLine("/// <summary>");
                itw.WriteLine($"///   Initializes a new instance of the <see cref=\"{document.ClassName}\"/> class.");
                itw.WriteLine("/// </summary>");
                foreach (JTypeDescriptor descriptor in document.Properties)
                {
                    string[] split = descriptor.Specification.Split(' ');
                    string propType = split[0];
                    string propName = split[1];

                    string propNameButCamelCase = FirstCharToLower(propName);

                    itw.WriteLine($"/// <param name=\"{propNameButCamelCase}\">");
                    itw.WriteLine($"///   <para>The parameter that initializes the value <see cref=\"{propName}\" />.</para>");
                    itw.WriteLine("/// </param>");
                }

                string constructorArgs =
                    string.Join(", ",
                        document.Properties.Select(
                            x => $"{x.Specification.Split(' ')[0]} {FirstCharToLower(x.Specification.Split(' ')[1])}"));

                itw.WriteLine($"public {document.ClassName}({constructorArgs})");
                WriteOpenBlock();

                foreach (JTypeDescriptor descriptor in document.Properties)
                {
                    string name = descriptor.Specification.Split(' ')[1];

                    itw.WriteLine($"this.{name} = {FirstCharToLower(name)};");
                }

                WriteCloseBlock();

                itw.WriteLine($"/// <inheritdoc cref=\"object.GetHashCode()\" />");
                itw.WriteLine($"public override int GetHashCode()");
                WriteOpenBlock();

                itw.WriteLine($"var hashCode = new System.HashCode();");
                foreach (JTypeDescriptor desc in document.Properties)
                {
                    itw.WriteLine($"hashCode.Add({desc.Specification.Split(' ')[1]});");
                }

                itw.WriteLine("return hashCode.ToHashCode();");

                WriteCloseBlock();

                itw.WriteLine($"/// <inheritdoc cref=\"object.Equals(object?)\" />");
                itw.WriteLine($"public override bool Equals(object? other)");
                WriteOpenBlock();
                itw.WriteLine($"return other is {document.ClassName} value && Equals(value);");
                WriteCloseBlock();

                itw.WriteLine("/// <inheritdoc cref=\"IEquatable{T}.Equals\" />");
                itw.WriteLine($"public bool Equals({document.ClassName}? other)");
                WriteOpenBlock();
                itw.WriteLine($"return other is not null &&");

                int descriptorCount = document.Properties.Count;
                for (int i = 0; i < descriptorCount; i++)
                {
                    bool isLastDescriptor = i >= descriptorCount - 1;

                    JTypeDescriptor descriptor = document.Properties[i];
                    string descriptorType = descriptor.Specification.Split(' ')[0];
                    string descriptorName = descriptor.Specification.Split(' ')[1];

                    bool isWellKnownDotNetPrimitive =
                        descriptorType is "string"
                        or "int"
                        or "bool"
                        or "uint"
                        or "char"
                        or "sbyte"
                        or "byte"
                        or "ushort"
                        or "short"
                        or "long"
                        or "ulong"
                        // NULLABLE TYPES
                        or "string?"
                        or "int?"
                        or "bool?"
                        or "uint?"
                        or "char?"
                        or "sbyte?"
                        or "byte?"
                        or "ushort?"
                        or "short?"
                        or "long?"
                        or "ulong?";

                    string suffix = isLastDescriptor ? ";" : " &&";

                    if (isWellKnownDotNetPrimitive)
                    {
                        itw.WriteLine($"    this.{descriptorName} == other.{descriptorName}{suffix}");
                    }
                    else
                    {
                        itw.WriteLine($"    EqualityComparer<{descriptorType}>.Default.Equals(this.{descriptorName}, other.{descriptorName}){suffix}");
                    }
                }

                WriteCloseBlock();

                itw.WriteLine("/// <summary>");
                itw.WriteLine("///   Determines if these two instances are equal.");
                itw.WriteLine("/// </summary>");
                itw.WriteLine("/// <param name=\"lhs\">Left-hand-side instance</param>");
                itw.WriteLine("/// <param name=\"lhs\">Right-hand-side instance</param>");
                itw.WriteLine("/// <returns>");
                itw.WriteLine("///   true if <paramref name=\"lhs\" /> == <paramref name=\"rhs\" />, false otherwise.");
                itw.WriteLine("/// </returns>");
                itw.WriteLine($"public static bool operator ==({document.ClassName} lhs, {document.ClassName}? rhs)");
                WriteOpenBlock();
                itw.WriteLine($"return lhs.Equals(rhs);");
                WriteCloseBlock();

                itw.WriteLine("/// <summary>");
                itw.WriteLine("///   Determines if these two instances are not equal.");
                itw.WriteLine("/// </summary>");
                itw.WriteLine("/// <param name=\"lhs\">Left-hand-side instance</param>");
                itw.WriteLine("/// <param name=\"lhs\">Right-hand-side instance</param>");
                itw.WriteLine("/// <returns>");
                itw.WriteLine("///   true if <paramref name=\"lhs\" /> != <paramref name=\"rhs\" />, false otherwise.");
                itw.WriteLine("/// </returns>");
                itw.WriteLine($"public static bool operator !=({document.ClassName} lhs, {document.ClassName}? rhs)");
                WriteOpenBlock();
                itw.WriteLine($"return !lhs.Equals(rhs);");
                WriteCloseBlock();

                WriteCloseBlock();
            }

            WriteCloseBlock();

            void WriteOpenBlock()
            {
                //itw.WriteLine();
                itw.Write('{');
                itw.Indent++;
                itw.WriteLine();
            }

            void WriteCloseBlock()
            {
                itw.Indent--;

                itw.WriteLine("}");
            }
        }

        static void ExitProgramWithError(string message, int exitCode)
        {
            Console.WriteLine($"error: {message}");
            Console.WriteLine("Generating failed. Exiting...");

            Environment.Exit(exitCode);
        }

        static string FirstCharToLower(string s)
        {
            return char.ToLowerInvariant(s[0]) + s[1..];
        }
    }
}
